package yapl.interfaces;

import java.io.IOException;
import java.io.OutputStream;

/**
 * Compiler backend interface generating machine code for a stack machine.
 * The stack machine is supposed to comprise the following functional units:
 * <ul>
 * <li>expression stack for word-sized operands;</li>
 * <li>instruction memory storing the program code;</li>
 * <li>procedure stack storing stack frames of procedure calls;</li>
 * <li>static data area storing global data allocated at compile time;</li>
 * <li>heap memory storing data allocated at run time.</li>
 * </ul>
 * The compiler backend maintains a code buffer and a static data buffer.
 * Emitted machine code instructions are stored in the code buffer, the
 * static data buffer holds static data allocated at compile time. Both buffers
 * are written to an object file by the {@link #writeObjectFile(OutputStream)}
 * method. 
 * <p>
 * The machine word size is implementation-dependent and can be determined
 * using the {@link #wordSize()} method.
 * Procedure stack, static data area, and heap memory are supposed to be
 * word-addressed (however, this can be easily mapped to byte-addressed
 * memory by a concrete backend implementation), instruction memory is
 * byte-addressed.
 * </p>
 * <p>
 * Boolean values are represented numerically using machine words, see
 * {@link #boolValue(boolean)}.
 * </p>
 * <p>
 * Arrays of machine words may be allocated at run-time using the {@link #storeArrayDim(int)}
 * and {@link #allocArray()} methods. Array access methods ({@link #loadArrayElement()} and
 * {@link #storeArrayElement()} support one-dimensional arrays only, because multi-dimensional
 * arrays are implemented by hierarchies of one-dimensional arrays: an n-dimensional array
 * with length k of its first dimension is represented as a one-dimensional array of
 * k pointers to (n-1)-dimensional arrays. Hence, run-time allocation of multi-dimensional arrays
 * needs support by a recursive procedure in the run-time environment.
 * </p>
 * <p>
 * To support forward jumps generated by a single-pass compiler, this interface supports
 * the concept of address labels as usually implemented by assemblers. 
 * Symbolic labels (strings) are associated with addresses in instruction memory (see
 * {@link #assignLabel(String)} and are used to express jump targets. 
 * Backward jump targets will automatically be 
 * replaced by the corresponding address when generating machine code.
 * As the address of a forward jump target is not known at code emission time,
 * a dummy address operand will be emitted with the jump instruction, but the operand's
 * address will be added to the backpatching list associated with the jump target label.
 * When the label finally gets assigned to an address, all code locations contained in
 * the label's backpatching list will be "backpatched" with the real address.
 * </p>
 * <p>
 * By convention, parameters are passed to procedures on the expression stack, and any
 * return value is pushed to the expression stack by the called procedure, see
 * {@link #callProc(String)}. The called procedure stores its parameters in the
 * procedure stack frame to make it available as local variables, see
 * {@link #enterProc(String, int, boolean)} and {@link #paramOffset(int)}.
 * 
 * @author Mario Taschwer
 * @version $Id: BackendBinSM.java 147 2010-03-30 13:41:46Z mt $
 *
 */
public interface BackendBinSM
{
	/*--- implementation constants ---*/
	
	/**
	 * Return the machine word size in bytes.
	 */
    public int wordSize();

	/**
	 * Return numerical representation of boolean value.     
	 */
    public int boolValue(boolean value);

    /*--- address labels ---*/
    
    /**
     * Assign a label to the current code address. This is the address of
     * the next emitted instruction. Any addresses contained in the label's 
     * backpatching list are backpatched with the current code address.
     * @param label     address label; must not have been assigned before
     *                  (also not by {@link #enterProc(String, int, boolean)}
     *                  or by {@link #exitProc(String)}).
     */
    public void assignLabel(String label);

    /*--- object file I/O ---*/
    
	/**
	 * Write code and static data buffers to the given output stream.
	 * The output should conform to the object file format specified
	 * for the target machine.
	 * @param outStream     output stream.
	 * @throws IOException  if the output stream cannot be written to.
	 */
    public void writeObjectFile(OutputStream outStream) throws IOException;
    
    /*--- compile-time memory allocation ---*/
    
    /**
     * Allocate space in the static data area.
     * @param words    number of words to allocate space for.
     * @return         start address of allocated space.
     */
    public int allocStaticData(int words);

    /**
     * Allocate string constant in static data area.
     * The string constant will be copied to the static data buffer
     * and terminated by a zero byte.
     * @param string   string constant (not quoted).
     * @return         start address of allocated string in static data area. 
     */
    public int allocStringConstant(String string);

    /**
     * Allocate space on the procedure stack.
     * @param words    number of words to allocate space for.
     * @return         start address of allocated space on the procedure stack.
     */
    public int allocStack(int words);

    /*--- run-time memory allocation ---*/
    
	/**
	 * Emit code for storing the length of an array dimension
	 * in an auxiliary array descriptor used by {@link #allocArray()} only. 
	 * The length of the array dimension is popped from the expression stack.
	 * For an array with n dimensions, this method must be called for
	 * every dimension dim = 0, 1, ..., n-1 (in this order) prior to calling
	 * {@link #allocArray()}.
	 * @param dim     dimension number; starts at 0.
	 */
    public void storeArrayDim(int dim);

    /**
     * Emit code for allocating a (possibly multi-dimensional) integer array
     * on the heap. The lengths of the array dimensions must have been
     * stored in an auxiliary array descriptor by code emitted by 
     * {@link #storeArrayDim(int)} prior to calling this method.
     * In particular, the desired number of array dimensions is implicitly
     * defined by the number of prior {@link #storeArrayDim(int)} calls.
     * The array start address is returned on the expression stack at run-time.
     */
    public void allocArray();

    /*--- load/store operations ---*/
    
    /**
     * Emit code for pushing the given constant to the expression stack.
     */
    public void loadConst(int value);

    /**
     * Emit code for loading a word from memory to the expression stack.
     * @param addr           address within static data area or offset relative
     *                       to current frame pointer address (depending
     *                       on the value of <code>staticData</code>.
     * @param staticData     if <code>true</code>, the word is loaded from
     *                       the static data area; otherwise, the current
     *                       procedure stack frame is used.
     */
    public void loadWord(int addr, boolean staticData);

    /**
     * Store top-most word on expression stack in memory.
     * @param addr           address within static data area or offset relative
     *                       to current frame pointer address (depending
     *                       on the value of <code>staticData</code>.
     * @param staticData     if <code>true</code>, the word is stored in
     *                       the static data area; otherwise, the current
     *                       procedure stack frame is used.
     */
    public void storeWord(int addr, boolean staticData);

    /**
     * Emit code for loading an integer array element from heap memory to the
     * expression stack. The array index and the array base address
     * are popped from expression stack (in this order).
     * <pre>
     * Runtime effect: i = pop(), a = pop(), push(a[i])
     * </pre>
     */
	public void loadArrayElement();

    /**
     * Emit code for storing an integer array element in heap memory. 
     * The value to be stored, the array index, and the array base address
     * are popped from the expression stack (in this order).
     * <pre>
     * Runtime effect: v = pop(), i = pop(), a = pop(), a[i] = v
     * </pre>
     */
	public void storeArrayElement();

	/**
	 * Emit code for retrieving the length of an array from the array descriptor.
	 * The array base address is popped from 
	 * the expression stack.
	 * <pre>
	 * Runtime effect: push(arraylength(pop()))
	 * </pre>
	 */
	public void arrayLength();

    /*--- run-time I/O operations ---*/
    
	/**
	 * Emit code for printing an integer on expression stack.
	 * <pre>
	 * Runtime effect: print(pop())
	 * </pre>
	 */
	public void writeInteger();
	
    /**
     * Emit code for printing a string constant.
     * @param addr    start address of string constant in static data area. 
     */
    public void writeString(int addr);

    /*--- arithmetic operations ---*/
    
    /**
     * Emit code for arithmetic negation on expression stack.
     * <pre>
     * Runtime effect: push(-pop())
     * </pre>
     */
	public void neg();

    /**
     * Emit code for addition on expression stack.
     * <pre>
     * Runtime effect: b = pop(), a = pop(), push(a + b)
     * </pre>
     */
    public void add();

    /**
     * Emit code for subtraction on expression stack.
     * <pre>
     * Runtime effect: b = pop(), a = pop(), push(a - b)
     * </pre>
     */
    public void sub();

    /**
     * Emit code for multiplication on the expression stack.
     * <pre>
     * Runtime effect: b = pop(), a = pop(), push(a * b)
     * </pre>
     */
    public void mul();

    /**
     * Emit code for integer division on the expression stack.
     * <pre>
     * Runtime effect: b = pop(), a = pop(), push(a / b)
     * </pre>
     */
    public void div();

    /**
     * Emit code for modulo operation on the expression stack.
     * <pre>
     * Runtime effect: b = pop(), a = pop(), push(a % b)
     * </pre>
     */
    public void mod();

    /*--- logical operations ---*/
    
    /**
     * Emit code for logical AND operation on expression stack.
     * Assumes a numerical representation of boolean values.
     * @see #boolValue(boolean)
     */
    public void and();

    /**
     * Emit code for logical OR operation on expression stack.
     * Assumes a numerical representation of boolean values.
     * @see #boolValue(boolean)
     */
    public void or();

    /*--- comparison operations ---*/
    
    /**
     * Emit code for comparing the two top-most operands on the expression stack.
     * The boolean result value is pushed onto the expression stack.
     * <pre>
     * Runtime effect: b = pop(), a = pop(), push(a == b)
     * </pre>
     */
    public void isEqual();
    
    public void isNotEqual();

    /**
     * Emit code for comparing the two top-most operands on the expression stack.
     * The boolean result value is pushed onto the expression stack.
     * <pre>
     * Runtime effect: b = pop(), a = pop(), push(a < b)
     * </pre>
     */
    public void isLess();

    /**
     * Emit code for comparing the two top-most operands on the expression stack.
     * The boolean result value is pushed to the expression stack.
     * <pre>
     * Runtime effect: b = pop(), a = pop(), push(a <= b)
     * </pre>
     */
    public void isLessOrEqual();

    /**
     * Emit code for comparing the two top-most operands on the expression stack.
     * The boolean result value is pushed to the expression stack.
     * <pre>
     * Runtime effect: b = pop(), a = pop(), push(a > b)
     * </pre>
     */
	public void isGreater();

    /**
     * Emit code for comparing the two top-most operands on the expression stack.
     * The boolean result value is pushed to the expression stack.
     * <pre>
     * Runtime effect: b = pop(), a = pop(), push(a >= b)
     * </pre>
     */
	public void isGreaterOrEqual();

    /*--- jump instructions ---*/
    
    /**
     * Emit code for a conditional jump to the given address label
     * if the top-most expression stack element represents
     * the given boolean value (constant).
     */
    public void branchIf(boolean value, String label);

	/**
     * Emit code to unconditionally jump to the address defined by
     * the given label.
     */
    public void jump(String label);

    /*--- procedure calls ---*/
    
    /**
     * Emit code for calling a procedure.
     * Parameters are passed on the expression stack -
     * last parameter is on top of stack.
     * Called procedure pushes return value to expression stack.
     * @param name     address label of procedure used with
     *                 {@link #enterProc(String, int, boolean)}
     *                 (usually the procedure name).
     */
    public void callProc(String label);

    /**
     * Emit code for setting up a procedure stack frame (procedure prolog).
     * If the stack frame size is needed by the emitted code, 
     * it will be backpatched when {@link #exitProc(String)} is called.
     * If the procedure represents the main program, additional initialization
     * code (of runtime environment) may be emitted.
     * Any parameters will be popped from the stack and stored in the
     * procedure stack frame to make them available as
     * local variables, see also {@link #paramOffset(int)}.
     * @param label      address label for procedure entry address
     *                   (usually the procedure name).
     * @param nParams    number of parameters the procedure expects.
     * @param main       <code>true</code> if the procedure represents the
     *                   main program.
     */
    public void enterProc(String label, int nParams, boolean main);

    /**
     * Emit code for releasing the current procedure stack frame
     * and returning to the caller (procedure epilog).
     * The epilog is assigned an address label to be used as
     * a jump target for return statements.
     * @param label       address label of epilog, must not be equal to
     *                    the label given to {@link #enterProc(String, int, boolean)},
     *                    but should be derived from it (e.g. append the suffix _end
     *                    to the procedure name).
     */
    public void exitProc(String label);

    /**
     * Return address offset of formal parameter within current
     * procedure stack frame.
     * @param index    parameter index; the first parameter corresponds
     *                 to index 0.
     * @return         offset relative to current frame pointer address.
     */
    public int paramOffset(int index);

	public void storeStaticConst(int addr, int value);

	public void removeOperand();

}
